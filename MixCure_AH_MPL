# MixCure_AH_MPL.control: Function to control model parameters 
# n: sample size
# smooth: smooth parameter
# n.obs_basis: number of observed time points per uniform basis
# max.iter: a vector with the first value defining the maximum number of iterations for selecting the smooth parameter,
#           the second value the maximum number of iterations for estimating the Theta, Beta and Gamma parameters, and
#           the third value the total number of iterations allowed.
# tol_1: convergence tolerance value for the Primal-Dual (PD) interior point algorithm.
# tol_2: convergence tolerance value for the smooth value selection algorithm
# tau: parameter in PD interior point algorithm
# min.theta: the minimal baseline hazard estimate value, below which the theta estimates will be considered to be 0.
MixCure_AH_MPL.control = 
  function (n, smooth = 2000, n.obs_basis = 10, max.iter = c(100, 300, 5000), 
            tol_1 = 1e-10, tol_2 = 1e-5, tau = 1000, min.theta = 1e-10) 
  {
    if (!is.null(smooth)) {
      smooth = ifelse(smooth < 0, 1000, smooth)
    }
    else {
      smooth = 1000
    }
    if (!is.null(n.obs_basis)) {
      n.obs_basis = ifelse(n.obs_basis < 1 | n.obs_basis > 
                             floor(n/2), round(n^(1/5)), round(n.obs_basis))
    }
    else {
      n.obs_basis = round(n^(1/5))
    }
    max.iter = c(ifelse(max.iter[1] > 0, as.integer(max.iter[1]), 100), 
                 ifelse(max.iter[2] > 0, as.integer(max.iter[2]), 300), 
                 ifelse(length(max.iter) == 2, 5000, 
                        ifelse(max.iter[3] > ifelse(max.iter[2] > 0, as.integer(max.iter[2]), 5000), as.integer(max.iter[3]), 5000)))
    tol_1 = ifelse(tol_1 > 0 & tol_1 < 1, tol_1, 1e-10)
    tol_2 = ifelse(tol_2 > 0, tol_2, 1e-3)
    min.theta = ifelse(min.theta > 0 & min.theta < 0.001, min.theta, 
                       1e-10)
    out = list(smooth = smooth, n.obs_basis = n.obs_basis, max.iter = max.iter, 
               tol_1 = tol_1, tol_2 = tol_2, tau = tau, min.theta = min.theta)
    out
  }
  
# bins_mpl: Function to determine bins and bin length  
# input:
#   control: model parameters in MixCure_AH_MPL.control (control = MixCure_AH_MPL.control())
#   t_i1: observed time for left censoring, uncensoring, right censoring and left-end point of finite interval censoring
#   t_i2: observed time for right-end point of finite interval censoring
#   ctype: a matrix for censoring indicators
#   example:              ctype
#          t_i1    t_i2     r    e    l     i
#           a        1      NA   NA   TRUE  NA   (left censored at a)
#           b        1      TRUE NA   NA    NA   (right censored at b)
#           c        d      NA   NA   NA    TRUE (finite interval censored between (c, d))
#           f        1      NA   TRUE NA    NA   (exactly observed at f)
# output:
#   m: number of bins
#   Alpha: edge points at each bin
#   Delta: bin length
bins_mpl = function (control, t_i1, t_i2, ctype) 
{
  event = c(t_i1[ctype[, "e"]], t_i1[ctype[, "i"]], t_i2[ctype[, "i"]], 
            t_i1[ctype[, "l"]])
  count = control$n.obs_basis
  order_event = sort(event)
  n.obs = length(order_event)
  m = ceiling(n.obs/count)
  Alpha = matrix(0, m + 1, 1)
  for (j in 2:m){
    Alpha[j] = order_event[(j-1) * count]
  }
  t.obs = c(t_i1[ctype[, "i"]], t_i2[ctype[, "i"]], 
            t_i1[ctype[, "e"]], t_i1[ctype[, "r"]], t_i1[ctype[, "l"]])
  Alpha[m + 1] = max(t.obs)
  Delta = diff(Alpha)
  list(m = m, Alpha = Alpha, Delta = Delta)
}

# penalty_mpl: R matrix in the penalty term 
# input:
#   bins: output of the function bins_mpl (bins = bins_mpl(control, t_i1, t_i2, ctype))
# output:
#   M_R_mm: R matrix in the penalty term
penalty_mpl = function (bins) 
{
  m = bins$m
  M_R_mm = matrix(0, m, m)
  for (u in 1:m){
    M_R_mm[u, u] = 6
  }
  for (u in 1: (m-1)){
    M_R_mm[u+1, u] = -4
    M_R_mm[u, u+1] = -4
  }
  for (u in 1: (m-2)){
    M_R_mm[u, u+2] = 1
    M_R_mm[u+2, u] = 1
  }
  M_R_mm[1, 1] = M_R_mm[m, m] = 1
  M_R_mm[2, 2] = M_R_mm[m-1, m-1] = 5
  M_R_mm[2, 1] = M_R_mm[1, 2] = M_R_mm[m, m-1] = M_R_mm[m-1, m] = -2
  return(M_R_mm)
}

# basis_mpl: Function to determine basis for approximating baseline hazards
# input: 
#   x: time points to be evaluated
#   bins: output of the function bins_mpl
#   which: 1 for baseine hazard and 2 for cumulative haseline hazard
# output:
#   M_psi_nm: basis for baseline hazard
#   M_Psi_nm: basis for cumulative haseline hazard
basis_mpl = function(x, bins, which = c(1, 2)) 
{
  which.matrix = rep(T, 2)
  which.matrix[-which] = FALSE
  n = length(x)
  Alpha = bins$Alpha
  Delta = bins$Delta
  m = bins$m
  M_Psi_nm = M_psi_nm = matrix(0, n, m)
  u_i = sapply(x, function(y, lim = Alpha[-1L]) sum(lim < y) + 1L)
  for (i in 1:n) {
    M_psi_nm[i, u_i[i]] = 1
    M_Psi_nm[i, 1:u_i[i]] = c(if (u_i[i] > 1) {
      Delta[1:(u_i[i] - 1)]
    }, x[i] - Alpha[u_i[i]])
  }
  if (all(which.matrix)) {
    list(psi = M_psi_nm, Psi = M_Psi_nm)
  }
  else {
    if (which.matrix[1]) {
      M_psi_nm
    }
    else {
      M_Psi_nm
    }
  }
}


